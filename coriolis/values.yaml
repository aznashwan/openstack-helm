
# List of provider plugins to enable/include:
# TODO: unused yet, everything is hardcoded as enabled.
providers:
  source:
    - aws
    - azure
    - openstack
    - opc
    - oracle_vm
    - scvmm
    - vmware_vsphere
  destination:
    - aws
    - azure
    - oci
    - opc
    - oracle_vm
    - openstack
    - scvmm

# Labels used by openstack-helm:
labels:
  api:
    node_selector_key: openstack-control-plane
    node_selector_value: enabled
  conductor:
    node_selector_key: openstack-control-plane
    node_selector_value: enabled
  replica_cron:
    node_selector_key: openstack-control-plane
    node_selector_value: enabled
  worker:
    node_selector_key: openstack-control-plane
    node_selector_value: enabled
  web:
    node_selector_key: openstack-control-plane
    node_selector_value: enabled
  web-proxy:
    node_selector_key: openstack-control-plane
    node_selector_value: enabled
  job:
    node_selector_key: openstack-control-plane
    node_selector_value: enabled

release_group: null

images:
  tags:
     # TODO: check if these images are compatible:
    bootstrap: docker.io/openstackhelm/heat:stein-ubuntu_bionic
    db_init: docker.io/openstackhelm/heat:stein-ubuntu_bionic
    db_drop: docker.io/openstackhelm/heat:stein-ubuntu_bionic
    dep_check: quay.io/airshipit/kubernetes-entrypoint:v1.0.0
    # NOTE: db sync will be performed by the conductor on startup
    rabbit_init: docker.io/rabbitmq:3.7-management
    ks_user: docker.io/openstackhelm/heat:stein-ubuntu_bionic
    ks_service: docker.io/openstackhelm/heat:stein-ubuntu_bionic
    ks_endpoints: docker.io/openstackhelm/heat:stein-ubuntu_bionic
    coriolis_db_sync: registry.cloudbase.it/appliance/coriolis-conductor:latest
    coriolis_api: registry.cloudbase.it/appliance/coriolis-api:latest
    coriolis_conductor: registry.cloudbase.it/appliance/coriolis-conductor:latest
    coriolis_replica_cron: registry.cloudbase.it/appliance/coriolis-replica-cron:latest
    coriolis_worker: registry.cloudbase.it/appliance/coriolis-worker:latest
    coriolis_web: registry.cloudbase.it/appliance/coriolis-web:latest
    coriolis_web_proxy: registry.cloudbase.it/appliance/coriolis-web-proxy:latest
  pull_policy: "IfNotPresent"
  imageCredentials:
    coriolisImagePullSecret: cbslreg
  local_registry:
    active: false
    exclude:
      - dep_check
      - image_repo_sync

pod:
  security_context:
    coriolis_api:
      pod:
        runAsUser: 42424
      container:
        coriolis_api:
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
    coriolis_conductor:
      pod:
        runAsUser: 42424
      container:
        coriolis_conductor:
          redOnlyRootFilesystem: true
          # TODO: ???
          runAsUser: 0
    coriolis_replica_cron:
      pod:
        runAsUser: 42424
      container:
        coriolis_replica_cron:
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
    coriolis_worker:
      pod:
        runAsUser: 42424
      container:
        # TODO: do init stuff like downloading/setting vixDiskLib
        init_coriolis_conf:
          runAsUser: 0
          readOnlyRootFilesystem: true
        coriolis_worker:
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
        # TODO:
        # - define check/create/mount external bin dir
    coriolis_web:
      pod:
        runAsUser: 42424
      container:
        # TODO: define:
        init_coriolis_web_conf:
          runAsUser: 0
          readOnlyRootFilesystem: true
        coriolis_web:
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
    coriolis_web_proxy:
        # TODO: define:
        init_coriolis_web_proxy_conf:
          runAsUser: 0
          readOnlyRootFilesystem: true
        coriolis_web_proxy:
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false

  affinity:
    anti:
      type:
        default: preferredDuringSchedulingIgnoredDuringExecution
      topologyKey:
        default: kubernetes.io/hostname
      weight:
        default: 10

  mounts:
    # NOTE: used to specify any additional desired mounts
    # The standard mounts (ex: /etc and binary files) are handled
    # in the templates automatically:
    coriolis_api:
      init_container: null
      coriolis_api:
        volumeMounts:
        volumes:
    coriolis_conductor:
      init_container: null
      coriolis_conductor:
        volumeMounts:
        volumes:
    coriolis_replica_cron:
      init_container: null
      coriolis_replica_cron:
        volumeMounts:
        volumes:
    coriolis_worker:
      init_container: null
      coriolis_worker:
        volumeMounts:
        volumes:
    coriolis_web:
      init_container: null
      coriolis_web:
        volumeMounts:
        volumes:
    coriolis_web_proxy:
      init_container: null
      coriolis_web_proxy:
        volumeMounts:
        volumes:
    coriolis_db_sync:
      init_container: null
      coriolis_db_sync:
        volumeMounts:
        volumes:

  replicas:
    api: 1
    conductor: 1
    replica_cron: 1
    worker: 1
    web: 1
    web_proxy: 1

  lifecycle:
    upgrades:
      deployments:
        # NOTE: useful when upgrading the chart:
        revision_history: 1
        pod_replacement_strategy: RollingUpdate
        rolling_update:
          max_unavailable: 1
          max_surge: 3
    disruption_budget:
      api:
        min_available: 0
    termination_grace_period:
      api:
        timeout: 30

  resources:
    # TODO: try enabling to see how it works:
    enabled: false
    api:
      requests:
        memory: "128Mi"
        cpu: "100m"
      limits:
        memory: "1024Mi"
        cpu: "2000m"
    conductor:
      requests:
        memory: "128Mi"
        cpu: "100m"
      limits:
        memory: "1024Mi"
        cpu: "2000m"
    replica_cron:
      requests:
        memory: "128Mi"
        cpu: "100m"
      limits:
        memory: "1024Mi"
        cpu: "2000m"
    worker:
      requests:
        memory: "128Mi"
        cpu: "100m"
      limits:
        memory: "1024Mi"
        cpu: "2000m"
    web:
      requests:
        memory: "128Mi"
        cpu: "100m"
      limits:
        memory: "1024Mi"
        cpu: "2000m"
    web-proxy:
      requests:
        memory: "128Mi"
        cpu: "100m"
      limits:
        memory: "1024Mi"
        cpu: "2000m"
    jobs:
      # TODO: check jobs list:
      bootstrap:
        requests:
          memory: "128Mi"
          cpu: "100m"
        limits:
          memory: "1024Mi"
          cpu: "2000m"
      clean:
        requests:
          memory: "128Mi"
          cpu: "100m"
        limits:
          memory: "1024Mi"
          cpu: "2000m"
      create_internal_tenant:
        requests:
          memory: "128Mi"
          cpu: "100m"
        limits:
          memory: "1024Mi"
          cpu: "2000m"
      db_init:
        requests:
          memory: "128Mi"
          cpu: "100m"
        limits:
          memory: "1024Mi"
          cpu: "2000m"
      db_sync:
        requests:
          memory: "128Mi"
          cpu: "100m"
        limits:
          memory: "1024Mi"
          cpu: "2000m"
      db_drop:
        requests:
          memory: "128Mi"
          cpu: "100m"
        limits:
          memory: "1024Mi"
          cpu: "2000m"
      ks_endpoints:
        requests:
          memory: "128Mi"
          cpu: "100m"
        limits:
          memory: "1024Mi"
          cpu: "2000m"
      ks_service:
        requests:
          memory: "128Mi"
          cpu: "100m"
        limits:
          memory: "1024Mi"
          cpu: "2000m"
      ks_user:
        requests:
          memory: "128Mi"
          cpu: "100m"
        limits:
          memory: "1024Mi"
          cpu: "2000m"
      rabbit_init:
        requests:
          memory: "128Mi"
          cpu: "100m"
        limits:
          memory: "1024Mi"
          cpu: "2000m"

bootstrap:
  enabled: true
  ks_user: admin
  # TODO: add functionalities such as pre-creating endpoints and such here

network:
  api:
    # TODO: what are these???
    ingress:
      public: true
      classes:
        namespace: "nginx"
        cluster: "nginx-cluster"
      annotations:
        nginx.ingress.kubernetes.io/rewrite-target: /
    external_policy_local: false
    node_port:
      enabled: false
      port: 30877

conf:
  paste:
    composite:coriolis-api:
      use: call:coriolis.api:root_app_factory
      /v1: coriolis-api-v1
    pipeline:coriolis-api-v1:
      pipeline: request_id faultwrap authtoken keystonecontext apiv1
    app:apiv1:
      paste.app_factory: coriolis.api.v1.router:APIRouter.factory
    filter:authtoken:
      paste.filter_factory: keystonemiddleware.auth_token:filter_factory
    filter:faultwrap:
      paste.filter_factory: coriolis.api.middleware.fault:FaultWrapper.factory
    filter:keystonecontext:
      paste.filter_factory: coriolis.api.middleware.auth:CoriolisKeystoneContext.factory
    filter:request_id:
      paste.filter_factory: oslo_middleware.request_id:RequestId.factory
  policy:
    admin: "role:admin"
    admin_or_owner: "rule:admin or project_id:%(project_id)s"

    migration:providers:list: "rule:admin_or_owner"

    migration:endpoints:create: "rule:admin_or_owner"
    migration:endpoints:list: "rule:admin_or_owner"
    migration:endpoints:show: "rule:admin_or_owner"
    migration:endpoints:update: "rule:admin_or_owner"
    migration:endpoints:delete: "rule:admin_or_owner"
    migration:endpoints:validate_connection: "rule:admin_or_owner"
    migration:endpoints:list_instances: "rule:admin_or_owner"
    migration:endpoints:get_instance: "rule:admin_or_owner"
    migration:endpoints:list_networks: "rule:admin_or_owner"
    migration:endpoints:list_source_options: "rule:admin_or_owner"
    migration:endpoints:list_destination_options: "rule:admin_or_owner"

    migration:migrations:create: "rule:admin_or_owner"
    migration:migrations:list: "rule:admin_or_owner"
    migration:migrations:show: "rule:admin_or_owner"
    migration:migrations:show_execution: "rule:admin_or_owner"
    migration:migrations:cancel: "rule:admin_or_owner"
    migration:migrations:delete: "rule:admin_or_owner"

    migration:replicas:create: "rule:admin_or_owner"
    migration:replicas:list: "rule:admin_or_owner"
    migration:replicas:show: "rule:admin_or_owner"
    migration:replicas:show_executions: "rule:admin_or_owner"
    migration:replicas:delete_disks: "rule:admin_or_owner"
    migration:replicas:delete: "rule:admin_or_owner"

    migration:replica_executions:create: "rule:admin_or_owner"
    migration:replica_executions:list: "rule:admin_or_owner"
    migration:replica_executions:show: "rule:admin_or_owner"
    migration:replica_executions:cancel: "rule:admin_or_owner"
    migration:replica_executions:delete: "rule:admin_or_owner"

    migration:replica_schedules:create: "rule:admin_or_owner"
    migration:replica_schedules:list: "rule:admin_or_owner"
    migration:replica_schedules:show: "rule:admin_or_owner"
    migration:replica_schedules:update: "rule:admin_or_owner"
    migration:replica_schedules:delete: "rule:admin_or_owner"
  coriolis:
    DEFAULT:
      # NOTE: will be set by openstack-helm:
      transport_url:
      messaging_transport_url:
      default_messaging_timeout: 60

      debug: true
      # TODO: abstract logging better:
      log_dir: /var/log/coriolis/
      log_config_append: /etc/coriolis/logging.conf
      logging_exception_prefix: "%(asctime)s.%(msecs)03d TRACE %(name)s %(instance)s"
      logging_debug_format_suffix: "from (pid=%(process)d) %(funcName)s %(pathname)s:%(lineno)d"
      logging_default_format_string: "%(asctime)s.%(msecs)03d %(levelname)s %(name)s [-] %(instance)s%(message)s"
      logging_context_format_string: "%(asctime)s.%(msecs)03d %(levelname)s %(name)s [%(request_id)s] %(instance)s%(message)s"

      include_task_info_in_migrations_api: false
      include_task_info_in_replicas_api: false
      include_task_info_in_replica_executions_api: false

      caching: true
      cache_time: 86400
      use_syslog: yes
      syslog_log_facility: LOG_LOCAL0

      internal_project_name: internal_coriolis
      internal_user_name: internal_coriolis

    cache:
      # TODO: enable caching
      enabled: false
      backend: dogpile.cache.memcached
      backend_argument: url:localhost:11211

    database:
      # NOTE: to be set by openstack-helm:
      connection:
      max_retries: -1

    keystone_authtoken:
      # NOTE: all the other required params will be set in the configmap-etc job:
      auth_version: v3
      auth_type: password
      memcache_security_strategy: ENCRYPT
    oslo_concurrency:
      lock_path: "/var/lib/coriolis/tmp"
    oslo_messaging_notifications:
      driver: messagingv2
    trustee:
      # TODO:
    keystone:
      # TODO:
    oslo_policy:
      # TODO: avoid hardcoding this:
      policy_file = /etc/coriolis/policy.json
    conductor:
      debug_os_morphing_errors: false
      conductor_rpc_timeout: 60
    worker:
      worker_rpc_timeout: 60

  providers:
    aws_migration_provider:
      migr_image_map:
      migr_image_username_map:
      worker_instance_type: t2.medium
      shutdown_migrated_instance: false
      instance_type:
      retain_source_ip: false
      default_storage_type: standard
      availability_zone: az1

    azure_migration_provider:
      export_location: westus
      export_worker_size: Standard_D1
      export_worker_image:
        version: latest
        publisher: Canonical
        offer: UbuntuServer
        sku: 18.04-LTS
      export_arm_resource_api_version:
      export_arm_compute_api_version:
      export_arm_network_api_version:
      export_blob_storage_api_version:

      migr_location: westus
      storage_account_name:
      storage_container_name:
      disk_storage_backing_type:
      default_vm_size:
      linux_migr_image:
        version: latest
        publisher: Canonical
        offer: UbuntuServer
        sku: 18.04-LTS
      windows_migr_image:
        version: latest
        publisher: MicrosoftWindowsServer
        offer: WindowsServer
        sku: 2016-Datacenter-Server-Core
      default_worker_size:
      preserve_nic_ips: true
      arm_resource_api_version:
      arm_compute_api_version:
      arm_network_api_version:
      blob_storage_api_version:
      arm_storage_api_version:

      cloudbaseinit_x86_url: https://www.cloudbase.it/downloads/CloudbaseInitSetup_x86.zip
      cloudbaseinit_x64_url: https://www.cloudbase.it/downloads/CloudbaseInitSetup_x64.zip

    oci_migration_provider:
      migr_image_map:
        linux:
        windows:
      default_to_pv_mode: true
      shape_name: VM.Standard1.2
      migr_shape_name: VM.Standard1.2
      migr_subnet_id:
      compartment:
      set_public_ip:
      default_attach_type:
      windows_virtio_zip_url:

    opc_migration_provider:
      export_image_name: /oracle/public/OL_7.2_UEKR4_x86_64
      export_img_username:
      export_shape_name: oc3
      export_root_disk_size: 150
      shape_name: oc3

      migr_image_map:
        linux: /oracle/public/OL_7.5_UEKR4_x86_64_MIGRATION
        windows:
      migr_shape_name: oc3
      default_volume_pool: /oracle/public/storage/default
      migr_network_name:
      windows_pv_drivers_url: https://cloudbase.it/downloads/app/ovm/ovm_win_pv_drivers_all_323_bare_root.zip

    openstack_migration_provider:
      replica_export_mechanism: coriolis_backups
      glance_api_version: 1
      allow_untrusted_swift: false
      custom_os_type_map:
      volume_backups_container:
      cinder_ceph_timeout: 30
      cinder_ceph_backups_diff_hash_algorithm:
      export_image:
      export_interim_volume_type:
      export_worker_boot_from_volume:
      export_worker_volume_type:
      export_worker_volume_size:
      export_flavor_name:
      export_network:
      export_worker_use_fip:
      export_fip_pool_name:
      export_worker_use_config_drive:

      delete_disks_on_vm_termination: true
      migr_image_map:
      list_all_destination_networks:
      volumes_are_zeroed:
      hypervisor_type:
      migr_worker_boot_from_volume: false
      migr_worker_volume_size:
      migr_worker_volume_type:
      default_cinder_volume_type:
      default_security_groups:
      migr_network:
      migr_worker_use_fip: true
      migr_fip_pool_name:
      migr_flavor_name:
      migr_worker_use_config_drive:
      set_dhcp: true
      port_reuse_policy: keep_mac
      preserve_fixed_ips: false
      instance_tags:
      use_floating_ip: false
      floating_ip_pool:
      server_group:
      windows_virtio_iso_url: https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso
      cloudbaseinit_x64_url: https://www.cloudbase.it/downloads/CloudbaseInitSetup_x64.zip
      cloudbaseinit_x86_url: https://www.cloudbase.it/downloads/CloudbaseInitSetup_x86.zip

    oracle_vm_migration_provider:
      export_template:
      export_template_username:
      export_template_password:

      migr_template_map:
        linux:
        windows:
      migr_template_username_map:
        linux:
        windows:
      migr_template_password_map:
        linux:
        windows:
      migr_network_name:
      server_pool_name:
      repository_name:
      leave_migrated_vm_off: false
      vm_domain_type: XEN_HVM_PV_DRIVERS
      virtual_disk_clone_type: THIN_CLONE
      cloudbaseinit_x86_url: https://www.cloudbase.it/downloads/CloudbaseInitSetup_x86.zip
      cloudbaseinit_x64_url: https://www.cloudbase.it/downloads/CloudbaseInitSetup_x64.zip
      windows_pv_drivers_url: https://cloudbase.it/downloads/app/ovm/ovm_win_pv_drivers_all_323_bare_root.zip

    scvmm_migration_provider:
      fallback_to_crash_consistent_snapshots: true
      verify_rct_server: false

      migr_template_name_map:
        linux:
        windows:
      migr_template_username_map:
        linux:
        windows:
      cloud_name:

    vmware_vsphere_migration_provider:
      automatically_enable_cbt: false
      vixdisklib_compatibility_version: 6.0
      # TODO: add mount for vixDiskLib:
      vixdisklib_library_directory: /lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu

  logging:
    loggers:
      keys:
        - root
        - coriolis
    handlers:
      keys:
        - stdout
        - stderr
        - "null"
    formatters:
      keys:
        - context
        - default
    logger_root:
      level: WARNING
      handlers: stdout
    logger_coriolis:
      level: DEBUG
      handlers:
        - stdout
      qualname: coriolis
    logger_amqp:
      level: WARNING
      handlers: stderr
      qualname: amqp
    logger_amqplib:
      level: WARNING
      handlers: stderr
      qualname: amqplib
    logger_eventletwsgi:
      level: WARNING
      handlers: stderr
      qualname: eventlet.wsgi.server
    logger_sqlalchemy:
      level: WARNING
      handlers: stderr
      qualname: sqlalchemy
    logger_boto:
      level: WARNING
      handlers: stderr
      qualname: boto
    # TODO: research logging options for coriolis-logger:
    handler_null:
      class: logging.NullHandler
      formatter: default
      args: ()
    handler_stdout:
      class: StreamHandler
      args: (sys.stdout,)
      formatter: context
    handler_stderr:
      class: StreamHandler
      args: (sys.stderr,)
      formatter: context
    formatter_context:
      class: oslo_log.formatters.ContextFormatter
      datefmt: "%Y-%m-%d %H:%M:%S"
    formatter_default:
      format: "%(message)s"
      datefmt: "%Y-%m-%d %H:%M:%S"
  rabbitmq:
    #NOTE(rk760n): adding rmq policy to mirror messages from notification queues and set expiration time for the ones
    policies:
      # TODO: check if these are necessary
      - vhost: "coriolis"
        name: "ha_ttl_coriolis"
        definition:
          #mirror messges to other nodes in rmq cluster
          ha-mode: "all"
          ha-sync-mode: "automatic"
          #70s
          message-ttl: 70000
        priority: 0
        apply-to: all
        pattern: '^(?!(amq\.|reply_)).*'
  # TODO: see what these are for:
  #resource_filters:
  #  volume:
  #    - name
  #    - status
  #    - metadata
  #    - bootable
  #    - migration_status
  #    - availability_zone
  #    - group_id
  #  backup:
  #    - name
  #    - status
  #    - volume_id
  #  snapshot:
  #    - name
  #    - status
  #    - volume_id
  #    - metadata
  #    - availability_zone

dependencies:
  dynamic:
    common:
      local_image_registry:
        jobs:
          - coriolis-image-repo-sync
        services:
          - endpoint: node
            service: local_image_registry
  static:
    api:
      jobs:
        - coriolis-db-sync
        - coriolis-ks-user
        - coriolis-ks-endpoints
        - coriolis-rabbit-init
      services:
        - endpoint: internal
          service: oslo_db
        # NOTE: required for auth:
        - endpoint: internal
          service: identity
    conductor:
      jobs:
        - coriolis-db-sync
        - coriolis-ks-user
        - coriolis-ks-endpoints
        - coriolis-rabbit-init
      services:
        - endpoint: internal
          service: oslo_db
        # NOTE: required for auth and checks:
        - endpoint: internal
          service: identity
    replica_cron:
      jobs:
        - coriolis-db-sync
        - coriolis-ks-user
        - coriolis-ks-endpoints
        - coriolis-rabbit-init
      services:
        - endpoint: internal
          service: oslo_db
        # TODO: check if required:
        - endpoint: internal
          service: identity
    worker:
      jobs:
        - coriolis-db-sync
        - coriolis-ks-user
        - coriolis-ks-endpoints
        - coriolis-rabbit-init
      services:
        - endpoint: internal
          service: oslo_db
        # NOTE: required for fetching Barbican secrets:
        - endpoint: internal
          service: identity
    bootstrap:
      services:
        - endpoint: internal
          service: identity
        - endpoint: internal
          service: volume
      pod:
        - requireSameNode: false
          labels:
            # NOTE: see what this reference points to:
            application: coriolis
            component: volume
    clean:
      jobs: null
    db_drop:
      services:
        - endpoint: internal
          service: oslo_db
    db_init:
      services:
        - endpoint: internal
          service: oslo_db
    db_sync:
      jobs:
        # TODO: define:
        - coriolis-db-init
      services:
        - endpoint: internal
          service: oslo_db
    ks_endpoints:
      jobs:
        # TODO: define:
        - coriolis-ks-service
      services:
        - endpoint: internal
          service: identity
    ks_service:
      services:
        - endpoint: internal
          service: identity
    ks_user:
      services:
        - endpoint: internal
          service: identity
    rabbit_init:
      services:
        - service: oslo_messaging
          endpoint: internal
    # TODO: check if required:
    image_repo_sync:
      services:
        - endpoint: internal
          service: local_image_registry
    create_internal_tenant:
      services:
        - endpoint: internal
          service: identity

# Names of secrets used by bootstrap and environmental checks:
secrets:
  identity:
    admin: coriolis-keystone-admin
    coriolis: coriolis-keystone-user
  oslo_db:
    admin: coriolis-db-admin
    coriolis: coriolis-db-user
  oslo_messaging:
    admin: coriolis-rabbitmq-admin
    coriolis: coriolis-rabbitmq-user
  tls:
    migration:
      api:
        public: coriolis-tls-public

# We use a different layout of the endpoints here to account for versioning
# this swaps the service name and type, and should be rolled out to other
# services.
endpoints:

  # TODO: add web-proxy?

  cluster_domain_suffix: cluster.local

  local_image_registry:
    name: docker-registry
    namespace: docker-registry
    hosts:
      default: localhost
      internal: docker-registry
      node: localhost
    host_fqdn_override:
      default: null
    port:
      registry:
        # TODO: add registry.cloudbase.it port too:
        node: 5000

  identity:
    name: keystone
    auth:
      admin:
        region_name: RegionOne
        username: admin
        password: password
        project_name: admin
        user_domain_name: default
        project_domain_name: default
      coriolis:
        role: admin
        region_name: RegionOne
        username: coriolis
        password: password
        project_name: service
        user_domain_name: service
        project_domain_name: service
    hosts:
      default: keystone
      internal: keystone-api
    host_fqdn_override:
      default: null
    path:
      default: /v3
    scheme:
      default: http
    port:
      api:
        default: 80
        internal: 5000
  migration:
    name: coriolis
    hosts:
      default: coriolis-api
      public: coriolis
    host_fqdn_override:
      default: null
      # NOTE(portdirect): this chart supports TLS for fqdn over-ridden public
      # endpoints using the following format:
      # public:
      #   host: null
      #   tls:
      #     crt: null
      #     key: null
    path:
      default: '/v1/%(tenant_id)s'
    scheme:
      default: 'http'
    port:
      api:
        default: 7667
        public: 80
  oslo_db:
    auth:
      # TODO: check where these are set/used and use them:
      admin:
        username: root
        password: password
      coriolis:
        username: coriolis
        password: password
    hosts:
      default: mariadb
    host_fqdn_override:
      default: null
    path: /coriolis
    scheme: mysql+pymysql
    port:
      mysql:
        default: 3306
  oslo_messaging:
    auth:
      # TODO: check where these are set/used and use them:
      admin:
        username: rabbitmq
        password: password
      coriolis:
        username: coriolis
        password: password
    statefulset:
      replicas: 2
      name: rabbitmq-rabbitmq
    hosts:
      default: rabbitmq
    host_fqdn_override:
      default: null
    path: /coriolis
    scheme: rabbit
    port:
      amqp:
        default: 5672
      http:
        default: 15672
  # TODO: see how/where to set these:
  oslo_cache:
    auth:
      # NOTE(portdirect): this is used to define the value for keystone
      # authtoken cache encryption key, if not set it will be populated
      # automatically with a random value, but to take advantage of
      # this feature all services should be set to use the same key,
      # and memcache service.
      memcache_secret_key: null
    hosts:
      default: memcached
    host_fqdn_override:
      default: null
    port:
      memcache:
        default: 11211
  # TODO: check what these are for and use them:
  kube_dns:
    namespace: kube-system
    name: kubernetes-dns
    hosts:
      default: kube-dns
    host_fqdn_override:
      default: null
    path:
      default: null
    scheme: http
    port:
      dns:
        default: 53
        protocol: UDP
  ingress:
    namespace: null
    name: ingress
    hosts:
      default: ingress
    port:
      ingress:
        default: 80

network_policy:
  # TODO: check what these are for:
  coriolis:
    ingress:
      - {}
    egress:
      - {}

manifests:
  # TODO: check where these are needed:
  configmap_bin: true
  configmap_etc: true

  deployment_api: true
  deployment_conductor: true
  deployment_replica_cron: true
  deployment_worker: true

  # TODO: enable web UI:
  deployment_web: false
  deployment_web_proxy: false

  # TODO: define these:
  ingress_api: true
  job_bootstrap: true
  job_clean: true
  job_create_internal_tenant: true
  job_db_init: true
  job_rabbit_init: true
  job_db_sync: true
  job_db_drop: true
  job_ks_endpoints: true
  job_ks_service: true
  job_ks_user: true
  job_storage_init: true

  # TODO: determine if these are needed:
  #pdb_api: true
  #pod_rally_test: true
  #pvc_backup: true
  #network_policy: false

  secret_db: true
  secret_ingress_tls: true
  secret_keystone: true
  secret_rabbitmq: true

  service_api: true
  service_ingress_api: true

########### auto-generated by `helm create`:
# replicaCount: 1

#image:
#  repository: nginx
#  pullPolicy: IfNotPresent

#imagePullSecrets: []
#nameOverride: ""
#fullnameOverride: ""

#serviceAccount:
#  # Specifies whether a service account should be created
#  create: true
#  # Annotations to add to the service account
#  annotations: {}
#  # The name of the service account to use.
#  # If not set and create is true, a name is generated using the fullname template
#  name:

#podSecurityContext: {}
#  # fsGroup: 2000

#securityContext: {}
#  # capabilities:
#  #   drop:
#  #   - ALL
#  # readOnlyRootFilesystem: true
#  # runAsNonRoot: true
#  # runAsUser: 1000

#service:
#  type: ClusterIP
#  port: 80

#ingress:
#  enabled: false
#  annotations: {}
#    # kubernetes.io/ingress.class: nginx
#    # kubernetes.io/tls-acme: "true"
#  hosts:
#    - host: chart-example.local
#      paths: []
#  tls: []
#  #  - secretName: chart-example-tls
#  #    hosts:
#  #      - chart-example.local

#resources: {}
#  # We usually recommend not to specify default resources and to leave this as a conscious
#  # choice for the user. This also increases chances charts run on environments with little
#  # resources, such as Minikube. If you do want to specify resources, uncomment the following
#  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
#  # limits:
#  #   cpu: 100m
#  #   memory: 128Mi
#  # requests:
#  #   cpu: 100m
#  #   memory: 128Mi

#nodeSelector: {}

#tolerations: []

#affinity: {}
